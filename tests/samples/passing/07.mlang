// mylang 実用的なコード例: 再帰による素数探索
// 目的: 指定された数までのすべての素数を見つけて表示する。
//       ループ構文がないため、すべての繰り返し処理を再帰で実現する。

// --- ユーティリティ関数 ---
// nがdivisorで割り切れるかを判定する。
fn is_divisible_by |n, divisor|
    // n - (divisor * (n / divisor)) == 0 であれば、割り切れる
    $n - (divisor * (n / divisor)) == 0$
: (i32, i32) -> bool;


// --- 素数判定のコアロジック ---
// nが、dから2までのいずれかの数で割り切れるかを再帰的にチェックする。
fn has_divisor_from |n, d|
    if $d <= 1$ {
        // 1までチェックして割り切れなければ、約数はない
        false
    } else {
        if is_divisible_by(n, d) {
            // 約数が見つかった
            true
        } else {
            // 次の数で再帰的にチェック
            has_divisor_from(n, $d - 1$)
        }
    }
: (i32, i32) -> bool;

// nが素数かどうかを判定する。
fn is_prime |n|
    if $n <= 1$ {
        false // 1以下は素数ではない
    } else {
        // n/2 までチェックする
        if has_divisor_from(n, $n / 2$) {
            false
        } else {
            true
        }
    }
: (i32) -> bool;


// --- メインの再帰ループ ---
// nから2までカウントダウンしながら、素数を見つけて表示する。
fn find_primes_down_from |n|
    if $n < 2$ {
        // ベースケース: 2より小さくなったら再帰を停止
        do_nothing()
    } else {
        // まず、現在のnより小さい数について再帰呼び出しを行う
        find_primes_down_from($n - 1$);

        // 再帰から戻ってきた後、現在のnが素数か判定して表示
        if is_prime(n) {
            println string_concat "Found prime: " (i32_to_string n);
        } else {
            {}
        }
    }
: (i32) -> ();

// 何も行わないUnitを返す関数
fn do_nothing || {} : () -> ();


// --- プログラムの暗黙的なエントリーポイント ---
let limit 100;
println "--- Prime Number Finder ---";
println string_concat "Finding all prime numbers up to " (i32_to_string limit);
println ""; // 空行を出力

find_primes_down_from(limit);

println "";
println "--- Search finished. ---";