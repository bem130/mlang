// Project Euler Problem 1: Multiples of 3 or 5
//
// 1000未満の3または5の倍数となっている自然数の総和を求めます。
// このプログラムは、再帰関数を用いてループをシミュレートし、問題を解決します。

// --- ヘルパー関数: nがdivisorの倍数かどうかを判定 ---
// mylangには剰余演算子(%)がないため、整数の割り算と掛け算を使って
// `n - (n / divisor) * divisor == 0` という計算で代用します。
fn is_multiple_of(n: i32, divisor: i32) -> bool {
    // 数式ブロック内で判定式を評価します。
    $n - (n / divisor) * divisor == 0$
}

// --- メインロジック: 再帰による総和計算 ---
// limit: 上限値 (この値は含まない)
// current: 現在調べている数値
// total_sum: これまでに見つかった倍数の合計
fn calculate_sum_recursive(limit: i32, current: i32, total_sum: i32) -> i32 {
    // ベースケース: 現在の数値が上限に達したら、計算を終了し合計値を返す
    if $current >= limit$ {
        total_sum
    } else {
        // 現在の数値が3または5の倍数かどうかをチェック
        // mylangには論理和(||)がないため、if式をネストして表現します
        let is_target = if is_multiple_of(current, 3) {
            true // 3の倍数ならtrue
        } else {
            is_multiple_of(current, 5) // そうでなければ5の倍数かチェック
        };

        // is_targetがtrueであれば、現在の数値を合計に加算する
        let new_sum = if is_target {
            $total_sum + current$
        } else {
            total_sum
        };
        
        // 次の数値で再帰呼び出し
        calculate_sum_recursive(limit, $current + 1$, new_sum)
    }
}

// --- プログラムのエントリーポイント ---
fn main() {
    println("--- Problem: Sum of multiples of 3 or 5 below 1000 ---");

    let limit = 1000;
    
    // 初期値 (current=1, total_sum=0) で再帰計算を開始
    let result = calculate_sum_recursive(limit, 1, 0);

    // 結果の出力
    let msg1 = string_concat("The sum of all the multiples of 3 or 5 below ", i32_to_string(limit));
    let msg2 = string_concat(msg1, " is: ");
    println(string_concat(msg2, i32_to_string(result)));
    // 期待される結果: 233168
}