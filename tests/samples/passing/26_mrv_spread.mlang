// 仕様書準拠のMRV (Multiple Return Values) テスト

// MRV定義: カンマ区切りで型を列挙 (括弧なし)
fn pair ||->i32, i32 { 10 20 }

// 3つの引数をとる関数
fn add3 |x: i32, y: i32, z: i32|->i32 $x + y + z$;
fn add2 |a: i32, b: i32|->i32 $a + b$;

fn main ||->() {
    println("--- MRV Spec Test ---");

    // 1. 展開コンテキスト (P-style)
    // pair はスタック上にフラットに展開される (10, 20)
    // add3 5 10 20 と解釈される
    let v1 add3 5 pair;
    println(string_concat("v1 (P-style): ", i32_to_string(v1)));

    // 2. タプル化コンテキスト (C-style) + スプレッド
    // pair() はタプル (10, 20) を返す
    // ... で展開され、引数リストは (5, 10, 20) となる
    let v2 add3(5, ...pair());
    println(string_concat("v2 (Spread): ", i32_to_string(v2)));

    // 3. 配列リテラルと混合スタイル
    // [pair()] => タプル化コンテキストなので [(10, 20)] (タプルの配列/リスト)
    // ...[ (10,20) ] => 配列の中身を展開 => (10, 20) というタプル値になる
    // add2( ...[(10, 20)] ) => add2( (10, 20) ) となり型エラー？
    // いや、仕様書の例 `add 1 add(...[pair()])` を見ると、
    // `add` がオーバーロード等でタプルを受け取るか、さらに展開される意図か。
    // ここでは仕様書の例「add 1 30 = 31」になるよう、
    // `add2` がタプルを受け取って内部で足すオーバーロードを定義するか、
    // 文脈依存でフラットになる挙動を確認する。
    
    // 仕様書4.5の例の再現:
    // add 1 [Result]
    // [Result] = add2(...[(10, 20)]) 
    // ここで `add2` が `(i32, i32)` を受け取るなら、`...` はタプルの中身を展開すべき。
    // つまり `add2(10, 20)` となる。
    
    let v3 add2 1 add2(...[pair()]);
    println(string_concat("v3 (Mixed): ", i32_to_string(v3)));
}