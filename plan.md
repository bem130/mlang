## 概要

`mylang`コンパイラは、フロントエンドとWasmバックエンドが大部分実装され、多くの言語機能が動作する段階にある。
今後の開発では、言語仕様をよりモダンで表現力の高い、式指向のスタイルへと進化させることを目指す。この変更は大規模なものとなるため、慎重かつ計画的に進める。

## 新言語仕様への移行計画

現在の`fn`キーワードを中心とした宣言的な構文から、`let`束縛とラムダ式を主体とする、より一貫性のある式指向の構文へと移行する。
現在のRust風の関数の定義は廃止する。
この変更は非常に多くの部分に影響するので、各所に大規模な改修が発生する可能性が高い。

### 1. 変数束縛と代入の仕様

*   **仕様**:
    *   **Immutable束縛**: `let 識別子 式`
    *   **Mutable束縛**: `let mut 識別子 式`
    *   **巻き上げ束縛 (Hoisted Binding)**: `let hoist 識別子 式`
    *   **代入**: `set 識別子 式`
    *   **戻り値**: 上記の束縛・代入式はすべて `()` (Unit) 型を返す。
    *   新しい記法では＝を使わないことに注意してください

### 2. 関数定義 (`let hoist` + ラムダ式)

*   **仕様**:
    *   関数は `|引数1, 引数2| 式` という記法を持つ**式（関数リテラル）**として定義する。
    *   関数定義は、他の値と同様に `let`, `let mut`, `let hoist` を使って変数に束縛する。
    *   自己再帰・相互再帰する関数は `let hoist` を用いて定義する。
    *   `|引数| 式` はそれ自体が完結した一つの式であるため、型注釈 `: (引数型...) -> 戻り値型` を直後に記述できる。

*   **サンプルコード**:

    ```mylang
    // 通常の関数
    let add |a, b| $a + b$ : (i32, i32) -> i32;

    // 自己再帰する関数 (巻き上げが必要)
    let hoist factorial |n| 
        if $n <= 1$ { 1 } else { $n * factorial($n - 1$) }
    : (i32) -> i32;

    // 相互再帰する関数 (let hoistを並べる)
    let hoist is_even |n| if $n==0$ {true} else {is_odd($n-1$)} : (i32)->bool;
    let hoist is_odd  |n| if $n==0$ {false} else {is_even($n-1$)} : (i32)->bool;
    ```

#### 注
`| |`が演算子になるのは数式数式の環境のみなので、ラムダ式を書くときに衝突することはありません
関数の引数の`| |`を適切に扱うためにレキサーを修正する必要があります

### 3. `fn` キーワードによるシンタックスシュガー

*   **仕様**:
    *   `let hoist` で関数を定義する際の記述を簡略化するため、`fn` キーワードをシンタックスシュガーとして再導入する。
    *   `fn` による定義は、コンパイラの内部で完全に `let hoist` を使った束縛に展開（脱糖）される。

*   **サンプルコード**:

    ```mylang
    // 通常の関数
    fn add |a, b| $a + b$ : (i32, i32) -> i32;

    // 自己再帰する関数
    fn factorial |n| 
        if $n <= 1$ { 1 } else { $n * factorial($n - 1$) }
    : (i32) -> i32;

    // 相互再帰する関数
    fn is_even |n| if $n==0$ {true} else {is_odd($n-1$)} : (i32)->bool;
    fn is_odd  |n| if $n==0$ {false} else {is_even($n-1$)} : (i32)->bool;
    ```

### 4. コンパイルモードと暗黙の `main` 関数

*   **仕様**:
    *   コンパイラは2つのモードで動作する：**実行形式モード（デフォルト）**と**ライブラリモード**。
    *   **実行形式モード**:
        *   コマンドライン引数で `--lib` フラグが**指定されていない**場合のデフォルトの動作。
        *   コンパイラは、入力されたソースコード全体を、暗黙的に生成される`main`関数の本体として扱う。
        *   これにより、`main`関数を明示的に定義することなく、トップレベルに直接処理を記述できる。
    *   **ライブラリモード**:
        *   `--lib` フラグが指定された場合の動作。
        *   まだ実装しないため、「まだサポートされていません」を表示する。
        *   ソースコードは一切変更されず、そのままコンパイルされる。`main`関数は暗黙的に生成されない。
        *   （将来的に、他のファイルからインポートして使用するモジュールを作成するために使用する）

*   **実装計画**:
    1.  **CLIツールの引数定義 (`Cli` 構造体) に、ブール値のフラグ `--lib` を追加する。**
    2.  コンパイラのエントリーポイント (`try_main` 関数内) で、`--lib` フラグが**指定されていないこと**を条件に、読み込んだソースコードをラップする処理を追加する。
    3.  ソースコードのラップは、`fn main || {{ {source_code} }} : () -> ();` という形式の文字列として行う。
    4.  ラップされた、あるいはラップされていないソースコードを `mylang_core::analyze_source` 関数に渡す。このアプローチにより、`mylang-core` はコンパイルモード（実行形式かライブラリか）を意識する必要がなくなる。

### 開発の進め方

1.  **ステップ1**: 変数束縛と代入の仕様変更 (`let`, `let mut`, `let hoist`, `set`) と、CLIへの `--lib` フラグ追加を実装する。
2.  **ステップ2**: ラムダ式と関数型の構文解析・型検査を実装する。
3.  **ステップ3**: `fn` キーワードをパーサーレベルで `let hoist` のエイリアスとして実装する。
4.  **ステップ4**: `Analyzer`の`let hoist`/`fn` 宣言に対する2パス解析（名前/型収集 -> 本体解析）を実装する。
5.  **ステップ5**: クロージャの実装（環境キャプチャ、エスケープ解析、コード生成）という最も複雑なタスクに取り組む。
6.  **ステップ6**: CLIツールに、`--lib` フラグの有無に応じた暗黙の`main`関数生成ロジックを実装する。
7.  **ステップ7**: すべての変更に合わせて、テストスイートを全面的に更新する。